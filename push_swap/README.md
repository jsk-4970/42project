*This project has been created as part of the 42 curriculum by jyamada.*

# Push_Swap

## Description

Push_Swapは、2つのスタックと限られた操作のみを使用して整数のスタックをソートするアルゴリズムプロジェクトです。目標は、できるだけ少ない操作回数で数値を昇順にソートすることです。

このプロジェクトは2つのプログラムで構成されています：
- **push_swap**: 与えられた数値をソートするための操作列を生成
- **checker**: 操作列が正しくスタックをソートするかを検証

### スタック操作

| 操作 | 説明 |
|------|------|
| `sa` | スタックAの先頭2つの要素を交換 |
| `sb` | スタックBの先頭2つの要素を交換 |
| `ss` | `sa`と`sb`を同時に実行 |
| `pa` | スタックBの先頭要素をスタックAにプッシュ |
| `pb` | スタックAの先頭要素をスタックBにプッシュ |
| `ra` | スタックAを回転（先頭要素が末尾に移動） |
| `rb` | スタックBを回転（先頭要素が末尾に移動） |
| `rr` | `ra`と`rb`を同時に実行 |
| `rra` | スタックAを逆回転（末尾要素が先頭に移動） |
| `rrb` | スタックBを逆回転（末尾要素が先頭に移動） |
| `rrr` | `rra`と`rrb`を同時に実行 |

### アルゴリズム

本実装ではビット単位の分離を用いた**基数ソート（Radix Sort）**を採用しています：
1. 各数値にランク（0からn-1のインデックス）を割り当て
2. 最下位ビットから最上位ビットまで、各ビット位置に基づいて数値を分離
3. ビットが0の数値はスタックBへプッシュ、ビットが1の数値はスタックAに残留
4. 各ビットの処理後、すべての数値をスタックAに戻す

このアプローチにより、予測可能な操作回数で効率的なソートが実現できます。

## Instructions

### コンパイル

```bash
make        # プログラムをコンパイル
make clean  # オブジェクトファイルを削除
make fclean # オブジェクトファイルと実行ファイルを削除
make re     # クリーンしてから再ビルド
```

### 実行方法

```bash
# 複数の引数で実行
./push_swap 4 67 3 87 23

# クォートで囲んだ文字列で実行
./push_swap "4 67 3 87 23"
```

### 検証

checkerプログラムを使用して出力を検証できます：

```bash
ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG
```

ソートが正しければ、checkerは`OK`と出力します。

### エラー処理

以下の場合、プログラムは標準エラー出力に`Error`を出力します：
- 整数以外の引数
- 整数オーバーフロー（INT_MINからINT_MAXの範囲外の値）
- 重複する数値

## Resources

### 参考資料
- [Push_swap Tutorial](https://medium.com/@ayogun/push-swap-c1f5d2d41e97) - push_swapアルゴリズムの包括的なガイド
- [基数ソートアルゴリズム](https://www.geeksforgeeks.org/radix-sort/) - 基数ソートの概念説明
- [C言語の連結リスト](https://www.learn-c.org/en/Linked_lists) - 連結リストデータ構造の理解

### AIの使用について

本プロジェクトでは以下の用途でAI（Claude）を使用しました：
- ソートアルゴリズムのロジックエラー特定のためのデバッグ支援
- メモリ管理とエッジケース処理のコードレビュー
- プロジェクト要件に基づくREADMEドキュメントの生成
